\lab{Python}{The Standard Library}{Standard Library}
\objective{Become familiar with the Python standard library}

One of the reasons Python is so useful as a scientific computing platform is because
it is not limited to only scientific computing.  Python has a very large and comprehensive standard library that is available with almost every Python environment.
In this lab, we will look at some of the useful parts of Python's standard library.  The standard library is comprised of over a hundred different modules that provide extra functionality to Python.
Modules can be imported via the \li{import} statement.

\section*{\texttt{math} Module}
The \li{math} module and its companion, \li{cmath} (for complex numbers), are very useful modules.
Common mathematical functions are defined in this module such as: \li{cos}, \li{sin}, \li{log}, \li{sqrt}, etc.  These functions wrap around the functionality of the C math library.

\begin{problem}
NumPy also implements these special mathematical functions.  However, there is a difference.
The NumPy variants are designed to work with NumPy arrays.  For scalar inputs, the functions
in Python's \li{math} or \li{numpy.math} are much faster.

Import NumPy with \li{import numpy as np}.  Time how long it takes to execute the following statements.
\begin{lstlisting}
np.sin(.5)
math.sin(.5)
\end{lstlisting}
\end{problem}

\section*{\texttt{random} Module}
Python includes an implementation of the Mersenne Twister pseudorandom number generator.
The \li{random} module contains many helpful functions for obtaining random numbers.  It also contains functions that operate on sequences.
The \li{randint()} function will return a random integer in a desired interval.  
\li{randrange()} will randomly select a random number from a range of numbers (similar to a range generated by \li{range()}, except it doesn't actually construct the range object).

For sequences, we can randomly choose elements using the \li{choice()} function.  If wish to randomly sample a sequence we can use \li{sample()}, which will return a random sampling of unique elements of desired length from the given sequence.  A sequence can be randomly shuffled in place by the \li{shuffle()} function.

The \li{random} module can sample from several distributions such as the uniform, normal, beta, gamma, exponential, and many others.  NumPy's \li{random} module is even more fully featured than the standard Python \li{random} module.

\section*{\texttt{csv} Module}
CSV files are common for exchanging data from databases and tables. 
Python has a very useful module for reading and writing data as comma separated values.
The \li{csv} module provides \li{reader} and \li{writer} objects.  There are also analogous \li{DictReader} and \li{DictWriter} objects that use dictionaries for handling data.
\begin{lstlisting}
import csv

#print the contents of a csv_file
with open('test.csv', 'r') as csv_file:
    csv_reader = csv.reader(csv_file)
    for line in csv_reader:
        print line
\end{lstlisting}

Writing with a CSV \li{writer} object is very similar to writing with a regular file object.

\begin{lstlisting}
contents = [["Column 1", "Column 2", "Column 3"],
            [0,1,2], [3, 2, 1], [4,5,2], [68, 38, 99]]
with open('test_out.csv', 'w') as csv_file:
    csv_writer = csv.writer(csv_file):
    for record in contents:
        csv_writer.writerow(record)
\end{lstlisting}

\begin{problem}
Practice reading and writing a CSV file.  Read \texttt{test.csv} and write it to \texttt{test_out.csv}.
When writing the CSV file, you must use a delimiter other than a comma.  Read the Python documentation for
instructions of how to do this.
\end{problem}


\section*{\texttt{sys} Module}
The \li{sys} module allow you to access information specific to the system running Python.
One of the most commonly used functions is \li{sys.argv}.  This returns a list of arguments passed to the current environment.  Accessing these arguments is important.  Many programs are written to execute differently based on the various arguments and options specified at execution.  For example, if we execute our script from the command line as follows
\begin{verbatim}
python myscript.py 5 no yes yes
\end{verbatim}
\li{sys.argv} would return the list
\begin{verbatim}
[`myscript.py', `5', `no', `yes', `yes']
\end{verbatim}
We can use \li{sys.argv} in combination with \li{argparse} to obtain a full featured argument processing system.

\section*{\texttt{pickle} Module}
The pickle module turns a Python object into a bytestream and saves it to a file.
It can also take a bytestream and turn it back into a Python object.
Pickle can be used to store any builtin Python data type such as lists, tuple, integers, etc.
Not all Python objects can be pickled.
Dumping a bytestream to a file is easy
\begin{lstlisting}
import pickle
a = range(10)
pickle.dump(a, open(`out.pkl', `w'))
\end{lstlisting}
What pickle does is write a small program that will rebuild your data structures when you read it.
When unpickling a file, pickle executes this file in the interpreter.  Because of this,
pickle is meant to be used as a temporary storage and data persistence mechanism.  It is not designed
to be used for long term storage of data.  The pickle documentation includes this warning
\begin{quote}
\textbf{The pickle module is not intended to be secure against erroneous or maliciously constructed data. Never unpickle data received from an untrusted or unauthenticated source.}
\end{quote}
To unpickle an object on simple use \li{pickle.load()}.  It accepts a file handle and returns the Python object it creates.

\begin{problem}
Create a list of numbers and strings.  Pickle the object to a file.  Inspect the contents of the file you created when pickling.  Unpickle the object.
\end{problem}

The \li{pickle} module only allows you to store one object per file.
If storing many objects is desired, you may want to use the \li{shelve} module.
This stores objects in a dictionary-like data structure with keys and values.
The values are pickled objects.  Since \li{shelve} relies on \li{pickle}, the
same warning against untrusted sources applies to \li{shelve} as well.

\section*{\texttt{timeit} Module}
This module is used to time the execution of small bits of Python code.
It is recommended to time lines of Python using this module because it avoids a number of common pitfalls in measuring execution time.  IPython's \li{\%timeit} magic function is a wrapper around this module.  

\begin{problem}
For most timing situations, we rely on IPython's \li{\%timeit} magic function.
One major drawback is it only works in IPython.
The solution to this problem will be useful in other labs where you will be
asked to time the performance of your coded solutions.
Write a function that will 
time the execution of another function.  You will need to use the \li{timeit} module.
Your function, should accept as arguments, a function, $f$, and any arguments that
should be passed to $f$.  Your function should return the minimum runtime.

Because of the way that Python's \li{timeit} module functions, we must use a \emph{callable}
function.  This essentially means we have to wrap the function we are timing and all of
its arguments into a function object that can be called by \li{timeit}.
This can be done by declaring a Python \li{lambda} function which takes no arguments.
\begin{lstlisting}
pfunc = lambda: f(*args, **kargs)
\end{lstlisting}
where \li{args} is a tuple and \li{kargs} is a dictionary.  
This syntax is explained in chapter 4 of the Official Python Tutorial).
\end{problem}


\section*{\texttt{os.path} Module}
The \li{os.path} module contains several methods for interfacing with the local file system in a cross-platform manner.
\begin{table}[h]
\begin{tabular}{|l|p{9cm}|}
\hline
\li{os.path.abspath} & Return a normalized absolute version given path. \\
\li{os.path.exists} & Return \li{True} if given path exists on the file system. \\
\li{os.path.isfile} & Return \li{True} if given path refers to an existing file. \\
\li{os.path.isdir} & Return \li{True} if given path refers to an existing directory. \\
\li{os.path.join} & Join one or more elements of a path intelligently, depending on the current platform. \\
\li{os.realpath} & Return the system's canonical form of a given path. \\
\li{os.split} & Split a given path into a tuple where the second entry is the final path element and the first element is all elements up to the final element. \\
\li{os.splitext} & Split a given path into a tuple of two elements where the second entry is the extension of the file referred to by the path.  The first entry contains everything up to the extension separator. \\
\hline
\end{tabular}
\caption{Some useful functions provided by \li{os.path}}
\end{table}

\section*{\texttt{collections} Module}
This module defines several specialized data structures to use in addition to the builtin
Python data structures.  Some of these useful data structures are named tuples, deques, and a Counter object.

Named tuples are designed to help improve code readability in some cases.
Standard tuples in Python are accessed by index.
Named tuples allow access via index or by a field name.
Compare the following
\begin{lstlisting}
from collections import namedtuple
pt = (32.1, 63.2)

Pt = namedtuple(`Point', `y x')
npt = Pt(32.1, 63.2)
\end{lstlisting}
The tuple \li{pt} is a standard tuple, which we can surmise represents the coordinates
of a pt in 2D space.  We must assume that \li{pt[0]} is the x-coordinate and \li{pt[1]}
is the y-coordinate.  When declaring a named tuple, we clearly defined what each index
represents.  We know for certain that \li{npt.x} is the x-coordinate and that \li{npt.y}
is the y-coordinate.

Ordered dictionaries are exactly like standard dictionaries except for one important
difference.  Ordered dictionaries remember the order in which key-value pairs were added
to the data structure.  This data structure is useful if we want to iterate over key-value pairs
of a dictionary in a specific order.

Default dictionaries are a very convenient way to set a default value for all new keys in a dictionary.  While this can be done with standard dictionaries using the \li{setdefault()} method,
using a default dictionary is simpler and faster.

\begin{problem}
A double-ended queue, or deque, can be thought of as a deck of cards.
Inserting and removing elements from either end is very efficient.
Python's deque implementation does not allow inserting into any other place
in the data structure except for the left and right ends.
A list, however, is very inefficient when adding elements to the front.
Write two functions that will rotate the elements of a deque and a list respectively.
To rotate, remove elements from the right end one by one and insert them on the left end.
Compare the timings you obtain from a deque and a list of 10000 elements.
\end{problem}
