\lab{Python}{Object Oriented Programming}{Object Oriented Programming}
\label{lab:OOP}

Believe it or not, if you have used Python, you have already used object oriented programming.

\section*{Fundamental Concepts}
At its core, object oriented programming relies on the manipulation and coordination of objects.
An object represents a piece of code that tracks a state and provides methods for discovering or altering the state.  For example, think of a die.  We can create an object that would represent our die.  There would be a variable that keeps track of the current side facing up.  We would define a method, \li{roll()}, that would simulate rolling the die by randomly choosing an integer between 1 and 6.  Whenever \li{roll()} is called, it would update the variable tracking the current side facing up before returning.  We could have another method named \li{peek()} that would let us look at the current side facing up without changing it.  A code representation of our die would look something like
\begin{lstlisting}
class Die(object):
    def __init__(self):
        self.face = random.randint(1, 6)
    def roll(self):
        self.face = random.randint(1, 6)
        return self.peek()
    def peek(self):
        return self.face
\end{lstlisting}

There are a few concepts that define object oriented programming
\begin{itemize}
\item Abstraction - appropriate representation of states and data
\item Encapsulation - independent behavior
\item Inheritance - relations between objects
\end{itemize}
The general advantage of using these concepts is that it helps with organizing code.  Abstraction permits the presentation of only necessary details about an object to the user.  For example, when we ask someone if they own a computer, we can use abstraction to ask the question ``Do you own a computer?'' rather than asking about each and every combination of hardware that we could classify as a computer.  Inheritance helps us easily achieve this abstraction.  We could have an object called \li{Computer}.  Various brands would then subclass, or inherit, the properties of \li{Computer}.  We could continue by having each product line inherit from their respective brands, until we arrive at the product level.  Then each individual product would represent an instantiation of that product's class.
%Need graphic
Encapsulation means each function contains all of the data it needs to calculate a result.  The principle of encapsulation discourages the use of global data structures.

Object oriented programming has gained popularity for many years.  Most modern programming languages support object oriented programming concepts.  Python is no exception.  In fact, everything in Python is an object.  We can create our own objects in Python by defining a \emph{class}.  A class is a blueprint that
describes how to create an object.
\begin{lstlisting}
class Backpack(object):
    pass
\end{lstlisting}
We now have a class \li{Backpack} which contains nothing.  We can create \li{Backpack} objects by
calling \li{b = Backpack()}, but we can't really do anything with it.  The variable \li{b} is now an
\emph{instance} of type \li{Backpack}.  Let's define an initial state for our object.
\begin{lstlisting}
class Backpack(object):
    def __init__(self):
        self.color = `Black'
\end{lstlisting}
Let's explain what is going on here.  The \li{self} is a reference the current instance of the class.
All class methods take a reference to the current instance of the class as their first argument.  It is a
very established convention to name this parameter \li{self}.  The \li{__init__} method is defined for all
objects and is executed immediately after the object is created.  Its purpose is the set the initial state
of the object.  In our backpack object, we set the color to black.  Thus all backpack objects will have the color black.
Let's have the user instantiate with a desired color
\begin{lstlisting}
class Backpack(object):
    def __init__(self, color=`black'):
        self.color = color
        self.contents = []
\end{lstlisting}
We can instantiate a \li{Backpack} object of the color purple.
\begin{lstlisting}
b = Backpack(color=`purple')
a = Backpack()
print b.color #prints `purple'
print a.color #prints `black'
\end{lstlisting}
The variable \li{self.color} is an instance variable.  It is defined for a particular instance of a backpack.
Finally, lets add some methods.
\begin{lstlisting}
class Backpack(object):
    def __init__(self, color=`black'):
        self.color = color
        self.contents = []
        
    def put(self, item):
        self.contents.append(item)
        
    def take(self, item):
        return self.contents.pop(self.contents.index(item))
        
    def __repr__(self):
        return str(self.contents)
\end{lstlisting}
We now have a complete model of a backpack that we can put items in and pull items out.
\begin{lstlisting}
b = Backpack(color=`green')
print b.color #prints `green'
b.color = `turqoise' # we can change an instance variable at any time
print b.color #prints `turqoise'
b.put(5)
b.put(3)
b.put(9)
b.put(1)
print b #prints `[5, 3, 9, 1]'
b.take(3)
print b #prints `[5, 9, 1]'
\end{lstlisting}

\begin{problem}
Create a \li{ComplexNumber} object that supports the basic operations of a complex number.
You must implement methods that will compare, add, subtract, multiply, divide, and conjugate complex numbers.
Also, implement a \li{norm()} method that will calculate the euclidean distance between two points on the complex plane.
\end{problem}


