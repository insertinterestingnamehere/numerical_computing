\lab{Algorithm}{The Knapsack Problem}{The Knapsack Problem}
\label{Ch:Knapsack}

\objective{This section teaches about NP-hard problems using the knapsack problem as an example.}

\section*{The Knapsack Problem}

%Lab \ref{Knapsack}

The two dimensional Knapsack problem is you are given a knapsack that can only hold a certain weight. You have a plethera of items that have value and weight. The goal is to find the combination of items that have the most value with out exceeding the weight.

A three dimensional version the items would have volume and the knapsack can only hold an certain volume as well as weight. 

This problem is has many different applications for disecion making in a wide variety of fields. Two examples are finding the least wasteful way to cut raw materials and the selection of capital investments and financial portfolios.

\begin{problem}
Write a function that solves the Knapsack problem by testing all the combination and choosing the one with the most value that meets the weight constraint. Only test it up to 15 objects.
\end{problem}

This is the only way to find the optimal solution, but there is a problem. Given $n$ objects the number of combinations is $n^2$. The complecity of the problem grows fast. For example, if you had 50 items, it would take more than 10 years to compute the optimal solution.

\begin{problem}
Time the Knapsack problem for the values $15-22$. How much more time does the algorithm take with each addition item.
\end{problem}

\section*{NP-Hard}

Any problem that is not polynomial time is know as NP-hard. The Knapsack Problem is a NP-hard problem. Using the branch and bound approach we can find the optimal solution in psuedo-polynomial time.

\section*{Branch and Bound method}
We calculate the optimal solution using only the first i items for weights 0 through W (where W is the max weight the knapsack can hold) 

We do this by intializing 0th row to being empty.
For i$>$0 row we go through j (being the weight) from 1 thorugh W. If the ith element's weight is more than j then the optimal combination is the same as it was for i-1. If ith element's weight is less than j, then we compare the combination at i-1 at wieght j to the combination i-1 at the weight j-the ith element weight plus the ith element. Whichever one has a higher value is the optimal combination using the first ith elements less than or equal to the wieght of j. You continue this until you have done all n elements. The combination using n items with a weight of W is guaranteed to be the optimal combination.

This only does $W*n$ checks, so it is a lot faster. This works by eliminating combinations that could not be the optimal solution

\begin{problem}
Write a function that solves the Knapsack problem using the branch and bound method.
\end{problem}

\begin{problem}
Time that algorithm for the values $100, 1000, 10000$. How much more time does the algorithm take with each addition factor of 10.
\end{problem}

\begin{problem}
Time that algorithm for the weights $100, 1000, 10000$. How much more time does the algorithm take with each addition factor of 10.
\end{problem}
